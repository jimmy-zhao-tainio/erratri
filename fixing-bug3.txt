What the dumps are telling us (in plain language)

From the non-manifold dump you described:

There are edges of count 1 that are A-only, and they all sit on the outer box faces near corners (z = ±100 in your scale). That’s “box vs cutter” gone wrong: we keep a lonely A patch without its mate.

There are edges with count 3 or 4, shared by both A and B, clustered around one rounded corner / tunnel region – coordinates like (±100,100,100) and slightly moved versions. That screams “box ∩ corner sphere ∩ tunnel” where multiple patches meet and the selection logic is keeping too much.

So the likely minimal culprits are:

Box ⧹ Sphere at a corner (corner-rounding only).

Box ⧹ Cylinder through the side (tunnel only).

Box ⧹ (Sphere ∪ Cylinder) at a corner where a tunnel meets a rounded corner.

We can turn those three into independent unit tests.

Strategy for tests

Each test should:

Construct small ClosedSurfaces using primitives directly (new Box, new Sphere, new Cylinder),

Call BooleanOps.DifferenceAB or BooleanOps.Union etc. directly,

Expect the call to succeed (no exception) and produce a non-empty BooleanMesh,

Let any exception bubble out so the test currently fails until you fix the kernel.

No Assert.Throws, no demo wiring.

I’ll write them in xUnit-style pseudocode; rename types/names as needed.

1. Box minus one corner sphere (corner rounding only)

This targets the “A-only edges near corners” without tunnels.

[Fact]
public void BooleanOps_BoxMinusCornerSphere_ShouldProduceManifoldMesh()
{
    // Box centered at origin, faces at ±100 (adjust to your actual Box ctor)
    var box = new Box(
        min: new Point(-100, -100, -100),
        max: new Point( 100,  100,  100));

    // Corner sphere sitting at (100,100,100), radius tuned so it just bites the corner.
    var cornerCenter = new Point(100, 100, 100);
    var cornerSphere = new Sphere(
        radius: 100,
        subdivisions: 3,
        center: cornerCenter);

    var a = box.Mesh;      // ClosedSurface
    var b = cornerSphere.Mesh;

    // Treat any exception as a BUG – this test is supposed to fail today.
    var result = BooleanOps.DifferenceAB(a, b);

    Assert.NotEmpty(result.Triangles);
}


If this already blows up with the same kind of A-only edges in the corner, you’ve got a much smaller repro than the full cheese.

2. Box minus a single tunnel cylinder

This is a minimal “drill one hole through the box” case. It probes whether tunnels alone cause the multi-count edges.

[Fact]
public void BooleanOps_BoxMinusSingleCylinder_ShouldProduceManifoldMesh()
{
    var box = new Box(
        min: new Point(-100, -100, -100),
        max: new Point( 100,  100,  100));

    // Cylinder through the box along, say, X axis.
    // Adapt to your actual Cylinder API (center + radius + height/axis).
    var cyl = new Cylinder(
        radius: 60,
        height: 300,
        axis: Axis.X,
        center: new Point(0, 0, 0));

    var a = box.Mesh;
    var b = cyl.Mesh;

    var result = BooleanOps.DifferenceAB(a, b);

    Assert.NotEmpty(result.Triangles);
}


If this is fine, you know tunnels alone are okay and the bug needs both tunnel + corner rounding (next test).

3. Box minus (corner sphere ∪ tunnel) at the same corner

Now we approximate the local configuration from the cheese: a rounded corner that also has a tunnel running nearby. This is the most likely minimal repro for your “3 or 4 triangles on the same edge” pattern.

[Fact]
public void BooleanOps_BoxMinusCornerSphereAndCylinder_ShouldProduceManifoldMesh()
{
    var box = new Box(
        min: new Point(-100, -100, -100),
        max: new Point( 100,  100,  100));

    var cornerCenter = new Point(100, 100, 100);
    var cornerSphere = new Sphere(
        radius: 100,
        subdivisions: 3,
        center: cornerCenter);

    // Cylinder grazing that corner – shift center so it passes close to (100,100,100)
    var cyl = new Cylinder(
        radius: 60,
        height: 300,
        axis: Axis.Y,  // for example
        center: new Point(100, 0, 100));

    // Build B as union FIRST, then subtract once.
    var union = BooleanOps.Union(cornerSphere.Mesh, cyl.Mesh);
    var a = box.Mesh;

    var result = BooleanOps.DifferenceAB(a, union);

    Assert.NotEmpty(result.Triangles);
}


If this fails with non-manifold edges that look like the cheese dump, you’ve isolated the kernel bug to “box vs union of corner spheres and tunnels”, which is a ton easier to reason about than the full eight-corner cheese.

4. Optional: “just two spheres at a corner”

If Cylinder is annoying or you suspect sphere–sphere–box is enough, a simpler version of (3) is:

var cornerSphere = new Sphere(... center (100,100,100));
var edgeSphere   = new Sphere(... center (100,  0,100)); // along one face

var union = BooleanOps.Union(cornerSphere.Mesh, edgeSphere.Mesh);
var result = BooleanOps.DifferenceAB(box.Mesh, union);


Same idea, one less primitive.

If you drop 2–3 of these into your test project and run them, you’ll very quickly see:

Which minimal configuration actually triggers the non-manifold error, and

You never had to touch Demo.Mesh at all.

From there we can tighten the repro even further (e.g. reduce radii, align axes more) once we know which of these blows up.