We have a regression in the boolean mesher when running a more complex "cheese" demo (box with tunnels and rounded corners).

Symptom:
- BooleanOps.DifferenceAB(a, b) throws in BooleanMeshAssembler.ValidateManifoldEdges with many non-manifold edges (counts 1, 3 or 4 instead of 2).
- boolean_mesh_nonmanifold_dump.txt and boolean_mesh_nonmanifold_detail.txt show that:
  - Some edges are A-only with count=1, all on the outer box faces near corners (z = -100 or z = 100).
  - Many edges around the rounded top corner region (near points like (±100,100,100), (100,75,25,100), (27.0884,81.2652,100), etc.) have total count 3 or 4 with a mix of A and B triangles.

Interpretation:
- The epsilon vertex canonicalizer is working; A/B endpoints for those edges are nearly identical.
- The bug is in patch assembly / selection:
  - Some A-side patches near corners are included without their mate, giving one-sided A edges.
  - Around the box/sphere/cylinder intersection, the boolean selection is keeping multiple overlapping patches (both A and B) along the same edge, instead of exactly one per side.

Task:
1) Add a minimal "cheese" boolean test in the test project
   - Reproduce the failing configuration from Demo.Mesh.Cheese (box minus tunnels / corner rounding).
   - Call BooleanOps.DifferenceAB(a, b) (or the same sequence of booleans used in the demo).
   - IMPORTANT: Treat the current exception as a BUG.
     - The test should expect the call to **succeed without throwing** and produce a BooleanMesh with no non-manifold edges.
     - Do NOT use Assert.Throws or try/catch. Let the current exception make the test fail until the bug is fixed.

2) Add better debug information in BooleanMeshAssembler for non-manifold edges
   - In addition to the existing per-edge ACount/BCount and the list of triangles, also log for each triangle:
     - its patch ID (from the BooleanPatchSet / TrianglePatchSet),
     - which mesh it came from (A or B),
     - maybe its "side" classification (inside/outside) if that already exists.
   - This should go into boolean_mesh_nonmanifold_detail.txt.

3) Add a temporary guard in BooleanMeshAssembler.ValidateManifoldEdges
   - When a non-manifold edge is detected, after logging the detailed info, throw as before, but include:
     - how many distinct patches are involved for that edge,
     - whether all triangles come from A, all from B, or mixed.
   - This will help reason about "one-sided A seams" vs "A+B overlapping patches".

4) Once the debug logging is richer, re-run the Demo.Mesh.Cheese boolean difference and inspect:
   - For the A-only edges with count=1 on z=-100 and z=100:
     - Check which patch(es) those triangles belong to.
     - We expect that some patch selection rule is incorrectly including a patch that sits entirely on the exterior of the final difference and should have been excluded.
   - For the 3/4-count edges in the top corner/tunnel region:
     - Check if we are combining two A patches that both represent the same sheet (e.g. cube cap and "adjusted" cap), or both an A patch and a B patch that should have been mutually exclusive for DifferenceAB.
     - The goal is to discover a misapplied boolean selection rule (e.g. for DifferenceAB we might be keeping both 'A outside B' and 'B outside A' patches along the same boundary in this configuration).

5) Do NOT try to "fix" this by relaxing the manifold validator or filtering duplicate edges.
   - We want to fix the patch classification/selection logic so that for every geometric edge there are exactly:
     - 0 or 1 A-side triangles, and
     - 0 or 1 B-side triangles,
     and the total count is exactly 2 in the assembled BooleanMesh.

Please:
- Add the failing cheese test (that currently throws) as described in step 1.
- Extend the non-manifold logging as in steps 2–3.
- Show me the updated logging code in BooleanMeshAssembler and the test case, so we can then reason about the patch-level patterns around these broken edges.
